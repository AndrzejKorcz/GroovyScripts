def props = [:]
def mp = [:]

node {
    checkout scm
    props.env = readProperties file:"${workspace}/env.properties"
    props.template = readProperties file:"${workspace}/template.properties"
    props.java = readProperties file:"${workspace}/java.properties"
    externalMethod = load("${workspace}/externalMethod.groovy") 
}

pipeline {
  agent {
    node {
      label 'master'
    }
  }
  
  environment {
      DEVOPS_FOLDER = "${props.env.source}"
  }
    
  parameters {
     string(name: 'Project', defaultValue: 'DEVOPS', description: 'Enter the name of the task in ACMS.')
     string(name: 'Developer', defaultValue: 'KORCZA03', description: 'Enter developer name.')
  }
  
  stages {
    stage("Prepare"){
        steps{
            script {
                println("Running job ${env.JOB_NAME}")

                def map = [:]
                map.put("props", props)
                map.put("params", params)
                map.put("workspace", workspace)
                
                dir("${DEVOPS_FOLDER}") {
                    externalMethod.cmdExec(externalMethod.cmdCopyPropFromAcmsTask(map))
                    externalMethod.cmdExec(externalMethod.copyPropFileFromIfs(map))                
			          }

                //get properties from acms task
                def localfile = "${workspace}/${params.Project}.properties"
                props.taskProperties = readProperties file:localfile
            }
        }
    }
    stage('Build') {
        steps {
            script {
                def map = [:]
                map.put("props", props)
                map.put("params", params)
                
			          dir("${DEVOPS_FOLDER}") {
                    externalMethod.cmdExec(externalMethod.acmsCompileTask(map))  
			          }
            }
        }
    }
  
    stage('UnitTest') {
        steps {
            script{
              def map = [:]
              map.put("props", props)   
            
              def list = externalMethod.prepareUnitTest(map)
              dir("${DEVOPS_FOLDER}") {
                list.each {
                    externalMethod.cmdExec(it)                      
                }
              }
            }
        }
    }
	
    stage('Deploy') {
       steps {
		      script {
              def map = [:]
              map.put("props", props)
              map.put("params", params)

			        dir("${DEVOPS_FOLDER}") {
                 externalMethod.cmdExec(externalMethod.acmsPromoteTask(map))
			        }

		      }
       }
    }

    stage('Test') {
      steps {
        script {
              def map = [:]
              map.put("props", props)
              map.put("params", params)
              def list = externalMethod.prepareIntegrationTest(map)
              dir("${DEVOPS_FOLDER}") {
                list.each {
                    externalMethod.cmdExec(it)                    
                }
              }             
        }
      }
    }
	
  }
  // 
  post {
    always {
      echo 'always runs regardless of the completion status of the Pipeline run'
    }
    success {
      echo 'step will run only if the build is successful'
    }
    failure {
      echo 'only when the Pipeline is currently in a "failed" state run, usually expressed in the Web UI with the red indicator.'
    }
    unstable {
      echo 'current Pipeline has "unstable" state, usually by a failed test, code violations and other causes, in order to run. Usually represented in a web UI with a yellow indication.'
    }
  }
}
